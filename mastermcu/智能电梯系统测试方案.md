# 智能电梯系统综合测试方案

## 1. 系统概述

### 1.1 系统架构
- **主控MCU (Master)**: STM32F407VET6
  - 负责电梯整体逻辑控制
  - 管理电机运动控制
  - 处理系统状态机
  - 显示系统状态（OLED）
  - 与从机通信（RS485）
  
- **从控MCU (Slave)**: STM32F103C8T6
  - 管理楼层传感器
  - 控制门禁系统（舵机）
  - 处理键盘输入
  - LED指示灯控制
  - 响应主机命令

### 1.2 通信协议
- **CAN总线**: 主控与步进电机驱动器通信
- **RS485**: 主从MCU之间通信
- **UART**: 调试和舵机控制

## 2. 测试策略

### 2.1 测试方法选择
建议采用**渐进式测试策略**：
1. **单元测试**：软件模拟测试各个模块
2. **集成测试**：软硬件结合测试
3. **系统测试**：完整系统功能验证
4. **压力测试**：极限条件测试

### 2.2 测试环境准备

#### 硬件需求：
- STM32F407开发板（主控）
- STM32F103开发板（从控）
- 步进电机及驱动器
- 舵机（模拟门控）
- 光电传感器（3个，模拟楼层）
- 4x4矩阵键盘
- LED指示灯
- OLED显示屏
- RS485转换模块
- CAN收发器
- 电源（5V/12V/24V）
- 示波器（用于信号分析）
- 逻辑分析仪（可选）

#### 软件需求：
- STM32CubeIDE
- 串口调试工具（如XCOM）
- CAN总线分析工具
- Python测试脚本（可选）

## 3. 详细测试方案

### 3.1 第一阶段：单元测试（软件模拟）

#### 3.1.1 主控MCU单元测试

**测试项目1：GPIO和基础外设初始化**
```c
// 测试代码示例
void Test_GPIO_Init(void) {
    // 测试LED闪烁
    printf("Testing LED...\n");
    for(int i = 0; i < 5; i++) {
        HAL_GPIO_WritePin(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_SET);
        HAL_Delay(500);
        HAL_GPIO_WritePin(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_RESET);
        HAL_Delay(500);
    }
    printf("LED test completed\n");
}
```

**测试项目2：OLED显示测试**
```c
void Test_OLED_Display(void) {
    printf("Testing OLED display...\n");
    Display_Init();
    Display_Clear();
    Display_Text(0, 10, "Test Line 1");
    Display_Text(0, 22, "Test Line 2");
    Display_Text(0, 34, "Test Line 3");
    Display_Update();
    HAL_Delay(2000);
    printf("OLED test completed\n");
}
```

**测试项目3：黑板模块测试**
```c
void Test_Blackboard(void) {
    printf("Testing Blackboard module...\n");
    
    // 测试状态设置和获取
    Blackboard_SetState(ELEVATOR_IDLE);
    assert(Blackboard_GetState() == ELEVATOR_IDLE);
    
    // 测试事件推送和弹出
    Blackboard_PushEvent(EVENT_BUTTON_PRESSED, 2);
    Event_t event;
    assert(Blackboard_PopEvent(&event) == true);
    assert(event.type == EVENT_BUTTON_PRESSED);
    assert(event.data == 2);
    
    // 测试楼层呼叫
    Blackboard_AddCall(1, CALL_UP);
    assert(Blackboard_HasCalls() == true);
    
    printf("Blackboard test completed\n");
}
```

**测试项目4：FSM状态机测试**
```c
void Test_FSM_Transitions(void) {
    printf("Testing FSM transitions...\n");
    
    // 测试校准->空闲
    Blackboard_SetState(ELEVATOR_CALIBRATING);
    g_blackboard.calibration.is_complete = true;
    FSM_Process();
    assert(Blackboard_GetState() == ELEVATOR_IDLE);
    
    // 测试空闲->上行
    Blackboard_SetState(ELEVATOR_IDLE);
    g_blackboard.current_floor = 0;
    Blackboard_AddCall(2, CALL_UP);
    FSM_Process();
    assert(Blackboard_GetState() == ELEVATOR_MOVING_UP);
    
    printf("FSM test completed\n");
}
```

#### 3.1.2 从控MCU单元测试

**测试项目5：键盘扫描测试**
```c
void Test_Keyboard(void) {
    printf("Testing keyboard module...\n");
    Keyboard_Init();
    
    // 模拟按键测试
    printf("Press keys on the keypad...\n");
    for(int i = 0; i < 10; i++) {
        uint8_t key = Keyboard_Scan();
        if(key != KEY_NONE) {
            printf("Key pressed: %d\n", key);
        }
        HAL_Delay(100);
    }
}
```

### 3.2 第二阶段：通信测试

#### 3.2.1 CAN通信测试

**测试项目6：CAN基础通信**
```c
void Test_CAN_Communication(void) {
    printf("Testing CAN communication...\n");
    
    // 发送测试帧
    uint8_t test_data[8] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
    if(CAN1_Send_Num(0x01, test_data) == HAL_OK) {
        printf("CAN frame sent successfully\n");
    }
    
    // 等待接收
    HAL_Delay(100);
    
    // 检查接收
    if(g_can_rx_flag) {
        printf("CAN frame received: ");
        for(int i = 0; i < 8; i++) {
            printf("%02X ", g_can_rx_data[i]);
        }
        printf("\n");
        g_can_rx_flag = 0;
    }
}
```

**测试项目7：电机控制命令测试**
```c
void Test_Motor_Commands(void) {
    printf("Testing motor control commands...\n");
    
    Motor_t test_motor;
    Motor_Init(&test_motor, 0x01);
    
    // 测试各种命令
    printf("1. Testing motor stop...\n");
    Motor_Stop(&test_motor);
    HAL_Delay(1000);
    
    printf("2. Testing set speed...\n");
    Motor_SetSpeed(&test_motor, 1000);
    HAL_Delay(1000);
    
    printf("3. Testing move to position...\n");
    Motor_MoveTo(&test_motor, 10000);
    HAL_Delay(3000);
    
    printf("4. Testing read position...\n");
    Motor_ReadPosition(&test_motor);
    HAL_Delay(100);
    printf("Current position: %ld\n", test_motor.current_position);
}
```

#### 3.2.2 RS485通信测试

**测试项目8：RS485主从通信**
```c
// 主机端测试
void Test_RS485_Master(void) {
    printf("Testing RS485 Master communication...\n");
    
    RS485_Init();
    
    // 发送心跳
    printf("Sending heartbeat...\n");
    RS485_SendHeartbeat();
    HAL_Delay(100);
    
    // 发送门控命令
    printf("Sending door open command...\n");
    RS485_SendDoorCommand(DOOR_OPEN);
    HAL_Delay(2000);
    
    printf("Sending door close command...\n");
    RS485_SendDoorCommand(DOOR_CLOSE);
    HAL_Delay(2000);
    
    // 请求传感器状态
    printf("Requesting sensor status...\n");
    RS485_RequestSensorStatus();
    HAL_Delay(100);
}

// 从机端测试
void Test_RS485_Slave(void) {
    printf("Testing RS485 Slave communication...\n");
    
    RS485_Slave_Init();
    
    while(1) {
        RS485_Slave_Handler();
        
        // 检查接收到的命令
        if(g_slave_blackboard.door_command != DOOR_IDLE) {
            printf("Received door command: %d\n", g_slave_blackboard.door_command);
            // 执行门控
            Servo_Control(g_slave_blackboard.door_command);
            g_slave_blackboard.door_command = DOOR_IDLE;
        }
        
        HAL_Delay(10);
    }
}
```

### 3.3 第三阶段：集成测试

#### 3.3.1 电机控制集成测试

**测试项目9：电机运动控制**
```c
void Test_Motor_Movement(void) {
    printf("=== Motor Movement Integration Test ===\n");
    
    // 初始化
    Motor_Init(&motor, 0x01);
    MotorAdv_Init(&motor_adv, &motor);
    
    // 测试1：基础移动
    printf("Test 1: Moving to floor positions\n");
    int32_t floor_positions[3] = {0, 50000, 100000}; // 假设的楼层位置
    
    for(int i = 0; i < 3; i++) {
        printf("Moving to floor %d (position: %ld)\n", i+1, floor_positions[i]);
        MotorAdv_MoveToPosition(&motor_adv, floor_positions[i]);
        
        // 等待到达
        while(MotorAdv_IsMoving(&motor_adv)) {
            printf("Current position: %ld\r", motor.current_position);
            HAL_Delay(100);
        }
        printf("\nReached floor %d\n", i+1);
        HAL_Delay(2000);
    }
    
    // 测试2：紧急停止
    printf("\nTest 2: Emergency stop\n");
    MotorAdv_MoveToPosition(&motor_adv, 50000);
    HAL_Delay(1000);
    MotorAdv_EmergencyStop(&motor_adv);
    printf("Emergency stop executed\n");
}
```

#### 3.3.2 传感器与电机协同测试

**测试项目10：楼层检测与定位**
```c
void Test_Floor_Detection(void) {
    printf("=== Floor Detection Test ===\n");
    
    // 初始化校准
    Calibration_Init(&calibration, &motor_adv);
    Calibration_Start(&calibration);
    
    printf("Starting calibration...\n");
    
    // 模拟校准过程
    while(!calibration.is_complete) {
        Calibration_Process(&calibration);
        
        // 模拟传感器触发
        if(motor.current_position > 10000 && !calibration.floor_found[0]) {
            printf("Floor 1 sensor triggered\n");
            Calibration_OnSensorTriggered(&calibration, 0);
        }
        if(motor.current_position > 50000 && !calibration.floor_found[1]) {
            printf("Floor 2 sensor triggered\n");
            Calibration_OnSensorTriggered(&calibration, 1);
        }
        if(motor.current_position > 90000 && !calibration.floor_found[2]) {
            printf("Floor 3 sensor triggered\n");
            Calibration_OnSensorTriggered(&calibration, 2);
        }
        
        HAL_Delay(50);
    }
    
    printf("Calibration complete!\n");
    for(int i = 0; i < 3; i++) {
        printf("Floor %d position: %ld\n", i+1, g_blackboard.floor_positions[i]);
    }
}
```

### 3.4 第四阶段：系统测试

#### 3.4.1 完整运行场景测试

**测试项目11：正常运行测试**
```c
void Test_Normal_Operation(void) {
    printf("=== Normal Operation Test ===\n");
    
    // 系统初始化
    System_Init();
    
    // 测试场景1：单一楼层呼叫
    printf("\nScenario 1: Single floor call\n");
    Blackboard_AddCall(2, CALL_UP);  // 3楼呼叫
    
    uint32_t start_time = HAL_GetTick();
    while(HAL_GetTick() - start_time < 30000) { // 30秒测试
        // 主循环处理
        Button_Process();
        RS485_Handler();
        MotorFSM_Update(&g_motor_fsm);
        FSM_Process();
        Update_Display();
        
        // 状态监控
        static uint32_t last_print = 0;
        if(HAL_GetTick() - last_print > 1000) {
            printf("State: %d, Floor: %d, Pos: %ld\n", 
                   g_blackboard.state, 
                   g_blackboard.current_floor,
                   g_blackboard.motor.current_position);
            last_print = HAL_GetTick();
        }
        
        HAL_Delay(10);
    }
    
    // 测试场景2：多楼层呼叫
    printf("\nScenario 2: Multiple floor calls\n");
    Blackboard_AddCall(0, CALL_UP);   // 1楼呼叫
    Blackboard_AddCall(2, CALL_DOWN); // 3楼呼叫
    Blackboard_AddCall(1, CALL_UP);   // 2楼呼叫
    
    // 继续运行测试...
}
```

**测试项目12：异常处理测试**
```c
void Test_Error_Handling(void) {
    printf("=== Error Handling Test ===\n");
    
    // 测试1：通信超时
    printf("\nTest 1: Communication timeout\n");
    // 断开RS485连接，观察系统行为
    
    // 测试2：电机故障
    printf("\nTest 2: Motor fault\n");
    // 模拟电机无响应
    
    // 测试3：传感器故障
    printf("\nTest 3: Sensor fault\n");
    // 模拟传感器信号异常
    
    // 测试4：紧急停止
    printf("\nTest 4: Emergency stop\n");
    Blackboard_PushEvent(EVENT_EMERGENCY_STOP, 0);
    FSM_Process();
    assert(Blackboard_GetState() == ELEVATOR_EMERGENCY_STOP);
}
```

### 3.5 第五阶段：性能与压力测试

**测试项目13：长时间运行测试**
```c
void Test_Long_Run(void) {
    printf("=== 24-Hour Endurance Test ===\n");
    
    uint32_t test_start = HAL_GetTick();
    uint32_t operation_count = 0;
    uint32_t error_count = 0;
    
    while(HAL_GetTick() - test_start < 86400000) { // 24小时
        // 随机生成楼层呼叫
        uint8_t random_floor = (HAL_GetTick() % 3);
        Blackboard_AddCall(random_floor, CALL_UP);
        
        // 运行系统
        // ... 主循环代码 ...
        
        operation_count++;
        
        // 每小时打印统计
        if((HAL_GetTick() - test_start) % 3600000 == 0) {
            printf("Hour %ld: Operations=%ld, Errors=%ld\n",
                   (HAL_GetTick() - test_start) / 3600000,
                   operation_count, error_count);
        }
    }
}
```

## 4. 测试检查清单

### 4.1 硬件连接检查
- [ ] 主控MCU电源连接（5V）
- [ ] 从控MCU电源连接（3.3V）
- [ ] CAN总线连接（CANH、CANL、终端电阻）
- [ ] RS485连接（A+、B-、GND）
- [ ] 步进电机电源（24V）
- [ ] 步进电机与驱动器连接
- [ ] 舵机电源与信号连接
- [ ] 传感器供电与信号连接
- [ ] 键盘矩阵连接
- [ ] OLED显示屏I2C连接
- [ ] LED指示灯连接

### 4.2 软件功能检查
- [ ] 系统启动自检
- [ ] 校准流程完成
- [ ] 楼层定位准确
- [ ] 按键响应正常
- [ ] 显示内容正确
- [ ] 门控动作正常
- [ ] 通信心跳稳定
- [ ] 状态切换流畅
- [ ] 异常恢复机制

### 4.3 性能指标检查
- [ ] 响应时间 < 100ms
- [ ] 定位精度 ±5mm
- [ ] 通信成功率 > 99%
- [ ] 系统稳定运行 > 24小时

## 5. 测试记录模板

```
测试日期：____年__月__日
测试人员：____________
测试版本：V____

测试项目：________________________
测试结果：□通过 □失败
问题描述：________________________
________________________
解决方案：________________________
________________________

备注：________________________
```

## 6. 常见问题与解决方案

### 6.1 通信问题
**问题**：CAN通信无响应
**解决**：
1. 检查终端电阻（120Ω）
2. 检查波特率设置
3. 使用示波器检查信号

**问题**：RS485数据错误
**解决**：
1. 检查A/B线是否接反
2. 增加通信延时
3. 检查地线连接

### 6.2 电机控制问题
**问题**：电机不转动
**解决**：
1. 检查电机电源
2. 检查驱动器使能信号
3. 验证CAN ID设置

**问题**：定位不准确
**解决**：
1. 重新校准
2. 检查传感器位置
3. 调整电机细分

### 6.3 系统稳定性问题
**问题**：系统死机
**解决**：
1. 检查栈溢出
2. 增加看门狗
3. 优化中断处理

## 7. 测试自动化建议

### 7.1 Python测试脚本框架
```python
import serial
import time
import can

class ElevatorTester:
    def __init__(self):
        self.uart = serial.Serial('COM3', 115200)
        self.can_bus = can.interface.Bus(bustype='pcan')
    
    def test_floor_call(self, floor):
        # 发送楼层呼叫命令
        cmd = f"CALL:{floor}\n"
        self.uart.write(cmd.encode())
        
        # 等待响应
        response = self.uart.readline()
        return "OK" in response.decode()
    
    def test_motor_position(self, position):
        # 通过CAN发送位置命令
        msg = can.Message(
            arbitration_id=0x01,
            data=[0x02, 0x01, 0x20, 
                  position & 0xFF, 
                  (position >> 8) & 0xFF,
                  0x00, 0x64, 0x00]
        )
        self.can_bus.send(msg)
        
        # 等待到位
        timeout = time.time() + 10
        while time.time() < timeout:
            rx_msg = self.can_bus.recv(timeout=0.1)
            if rx_msg and rx_msg.arbitration_id == 0x81:
                return True
        return False

# 使用示例
tester = ElevatorTester()
tester.test_floor_call(2)
tester.test_motor_position(50000)
```

### 7.2 持续集成建议
1. 使用Jenkins或GitLab CI
2. 每次代码提交自动编译
3. 硬件在环(HIL)测试
4. 测试报告自动生成

## 8. 总结

本测试方案采用渐进式策略，从单元测试到系统测试，逐步验证各个功能模块。建议按照以下顺序执行：

1. **第1周**：完成单元测试和通信测试
2. **第2周**：完成集成测试
3. **第3周**：完成系统测试和异常测试
4. **第4周**：完成性能测试和优化

关键成功因素：
- 详细的测试日志记录
- 问题及时跟踪解决
- 测试环境稳定可靠
- 团队协作与沟通

通过系统化的测试，确保智能电梯系统的可靠性、稳定性和安全性，为产品化奠定坚实基础。



按上键到最顶上，
用event和state两个逻辑驱动