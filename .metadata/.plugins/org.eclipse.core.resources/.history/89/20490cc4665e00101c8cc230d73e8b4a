#include "motor_control.h"

// 初始化电机
void Motor_Init(Motor_t* motor, uint16_t motor_id) {
    motor->motor_can_id = motor_id;
    motor->current_position = 0;
    motor->target_position = 0;
    motor->is_moving = false;
    motor->speed = 1000;  // 默认速度
    motor->status = MOTOR_STATUS_IDLE;
    motor->last_command_time = 0;
    motor->last_response_time = HAL_GetTick();

    // 启动CAN（如果还未启动）
    CAN1_UserFilterStart();
}

// 绝对位置移动
uint8_t Motor_MoveTo(Motor_t* motor, int32_t position) {
    uint8_t data[8] = {0};

    data[0] = MOTOR_CMD_MOVE_ABSOLUTE;
    data[1] = (position >> 24) & 0xFF;  // 位置高字节
    data[2] = (position >> 16) & 0xFF;
    data[3] = (position >> 8) & 0xFF;
    data[4] = position & 0xFF;          // 位置低字节
    data[5] = (motor->speed >> 8) & 0xFF;  // 速度高字节
    data[6] = motor->speed & 0xFF;         // 速度低字节
    data[7] = 0x00;  // 保留字节

    motor->target_position = position;
    motor->is_moving = true;
    motor->last_command_time = HAL_GetTick();

    return CAN1_Send_Num(motor->motor_can_id, data);
}

// 相对位置移动
uint8_t Motor_MoveSteps(Motor_t* motor, int32_t steps) {
    uint8_t data[8] = {0};

    data[0] = MOTOR_CMD_MOVE_RELATIVE;
    data[1] = (steps >> 24) & 0xFF;
    data[2] = (steps >> 16) & 0xFF;
    data[3] = (steps >> 8) & 0xFF;
    data[4] = steps & 0xFF;
    data[5] = (motor->speed >> 8) & 0xFF;
    data[6] = motor->speed & 0xFF;
    data[7] = 0x00;

    motor->target_position = motor->current_position + steps;
    motor->is_moving = true;
    motor->last_command_time = HAL_GetTick();

    return CAN1_Send_Num(motor->motor_can_id, data);
}

// 设置速度
uint8_t Motor_SetSpeed(Motor_t* motor, uint16_t speed) {
    uint8_t data[8] = {0};

    data[0] = MOTOR_CMD_SET_SPEED;
    data[1] = (speed >> 8) & 0xFF;
    data[2] = speed & 0xFF;
    data[3] = 0x00;
    data[4] = 0x00;
    data[5] = 0x00;
    data[6] = 0x00;
    data[7] = 0x00;

    motor->speed = speed;
    motor->last_command_time = HAL_GetTick();

    return CAN1_Send_Num(motor->motor_can_id, data);
}

// 停止电机
uint8_t Motor_Stop(Motor_t* motor) {
    uint8_t data[8] = {0};

    data[0] = MOTOR_CMD_STOP;
    data[1] = 0x00;
    data[2] = 0x00;
    data[3] = 0x00;
    data[4] = 0x00;
    data[5] = 0x00;
    data[6] = 0x00;
    data[7] = 0x00;

    motor->is_moving = false;
    motor->target_position = motor->current_position;
    motor->last_command_time = HAL_GetTick();

    return CAN1_Send_Num(motor->motor_can_id, data);
}

// 设置零点
uint8_t Motor_SetZero(Motor_t* motor) {
    uint8_t data[8] = {0};

    data[0] = MOTOR_CMD_SET_ZERO;
    data[1] = 0x00;
    data[2] = 0x00;
    data[3] = 0x00;
    data[4] = 0x00;
    data[5] = 0x00;
    data[6] = 0x00;
    data[7] = 0x00;

    motor->current_position = 0;
    motor->target_position = 0;
    motor->last_command_time = HAL_GetTick();

    return CAN1_Send_Num(motor->motor_can_id, data);
}

// 读取位置
uint8_t Motor_ReadPosition(Motor_t* motor) {
    uint8_t data[8] = {0};

    data[0] = MOTOR_CMD_READ_POSITION;
    data[1] = 0x00;
    data[2] = 0x00;
    data[3] = 0x00;
    data[4] = 0x00;
    data[5] = 0x00;
    data[6] = 0x00;
    data[7] = 0x00;

    motor->last_command_time = HAL_GetTick();

    return CAN1_Send_Num(motor->motor_can_id, data);
}

// 读取状态
uint8_t Motor_ReadStatus(Motor_t* motor) {
    uint8_t data[8] = {0};

    data[0] = MOTOR_CMD_READ_STATUS;
    data[1] = 0x00;
    data[2] = 0x00;
    data[3] = 0x00;
    data[4] = 0x00;
    data[5] = 0x00;
    data[6] = 0x00;
    data[7] = 0x00;

    motor->last_command_time = HAL_GetTick();

    return CAN1_Send_Num(motor->motor_can_id, data);
}

// 处理CAN接收消息
void Motor_ProcessRxMessage(Motor_t* motor, uint16_t rx_id, uint8_t* data) {
    // 检查是否是该电机的响应（通常响应ID = 发送ID + 偏移）
    if (rx_id != (motor->motor_can_id + 0x100)) {  // 假设响应ID偏移0x100
        return;
    }

    motor->last_response_time = HAL_GetTick();

    switch (data[0]) {
        case MOTOR_CMD_READ_POSITION:
            // 解析位置数据
            motor->current_position = (data[1] << 24) | (data[2] << 16) | (data[3] << 8) | data[4];
            break;

        case MOTOR_CMD_READ_STATUS:
            // 解析状态数据
            motor->status = data[1];
            motor->is_moving = (data[2] == 0x01);
            // 可以在这里解析更多状态信息
            break;

        case MOTOR_CMD_MOVE_ABSOLUTE:
        case MOTOR_CMD_MOVE_RELATIVE:
            // 移动命令的响应
            if (data[1] == 0x00) {  // 假设0x00表示成功
                // 命令执行成功
                motor->status = MOTOR_STATUS_RUNNING;
            } else {
                // 命令执行失败
                motor->status = MOTOR_STATUS_FAULT;
                motor->is_moving = false;
            }
            break;

        case MOTOR_CMD_STOP:
            // 停止命令响应
            motor->is_moving = false;
            motor->status = MOTOR_STATUS_IDLE;
            break;

        default:
            break;
    }
}

// 获取当前位置
int32_t Motor_GetPosition(Motor_t* motor) {
    return motor->current_position;
}

// 获取目标位置
int32_t Motor_GetTargetPosition(Motor_t* motor) {
    return motor->target_position;
}

// 检查是否正在运动
bool Motor_IsMoving(Motor_t* motor) {
    return motor->is_moving;
}

// 获取状态
uint8_t Motor_GetStatus(Motor_t* motor) {
    return motor->status;
}

// 获取速度
uint16_t Motor_GetSpeed(Motor_t* motor) {
    return motor->speed;
}

// 检查连接状态
bool Motor_IsConnected(Motor_t* motor) {
    uint32_t current_time = HAL_GetTick();
    // 如果超过1秒没有收到响应，认为断开连接
    return (current_time - motor->last_response_time) < 1000;
}

// 电机任务处理（定期调用）
void Motor_Task(Motor_t* motor) {
    static uint32_t last_status_read = 0;
    static uint32_t last_position_read = 0;
    uint32_t current_time = HAL_GetTick();

    // 每500ms读取一次位置
    if (current_time - last_position_read >= 500) {
        Motor_ReadPosition(motor);
        last_position_read = current_time;
    }

    // 每1000ms读取一次状态
    if (current_time - last_status_read >= 1000) {
        Motor_ReadStatus(motor);
        last_status_read = current_time;
    }

    // 检查超时
    if (current_time - motor->last_response_time > 2000) {
        motor->status = MOTOR_STATUS_TIMEOUT;
    }
}
