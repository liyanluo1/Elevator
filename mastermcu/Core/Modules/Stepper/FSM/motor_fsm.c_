#include "motor_fsm.h"
#include "../../CAN/can.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>  // For abs()

// 全局电机FSM实例
MotorFSM_t g_motor_fsm;

// 初始化电机FSM
void MotorFSM_Init(MotorFSM_t* fsm, MotorAdvanced_t* motor_adv) {
    memset(fsm, 0, sizeof(MotorFSM_t));
    
    fsm->motor_adv = motor_adv;
    fsm->current_state = MOTOR_STATE_IDLE;
    fsm->prev_state = MOTOR_STATE_IDLE;
    fsm->current_speed_percent = 0;
    fsm->target_speed_percent = 100;
}

// 主更新函数
void MotorFSM_Update(MotorFSM_t* fsm) {
    uint32_t current_time = HAL_GetTick();
    uint32_t elapsed = current_time - fsm->start_time;
    
    // 状态机处理
    switch (fsm->current_state) {
        case MOTOR_STATE_IDLE:
            // 空闲状态，等待外部调用StartMoving来启动
            // 或者等待位置调整
            if (fsm->position_error != 0) {
                fsm->current_state = MOTOR_STATE_ADJUST;
                fsm->start_time = current_time;
            }
            break;
            
        case MOTOR_STATE_ACCELERATING:
            // 加速阶段
            // 更新速度
            fsm->current_speed_percent += 10;  // 每次增加10%
            if (fsm->current_speed_percent >= fsm->target_speed_percent) {
                fsm->current_speed_percent = fsm->target_speed_percent;
                fsm->current_state = MOTOR_STATE_CRUISING;
            }
            
            // 继续生成脉冲 - 使用内部保存的方向
            MotorFSM_GeneratePulse(fsm, DIR_UP, fsm->current_speed_percent);
            break;
            
        case MOTOR_STATE_CRUISING:
            // 巡航阶段
            // 检查是否接近目标
            int32_t remaining = abs(fsm->target_position - fsm->motor_adv->actual_position);
            if (remaining < 1000) {  // 接近目标，开始减速
                fsm->current_speed_percent = 50;
            }
            
            if (remaining < 10) {  // 到达目标
                fsm->current_state = MOTOR_STATE_IDLE;
                MotorAdv_Stop(fsm->motor_adv);
                break;
            }
            
            // 继续移动
            MotorFSM_GeneratePulse(fsm, DIR_UP, fsm->current_speed_percent);
            
            // 检查超时
            if (elapsed > 30000) {  // 30秒超时
                fsm->current_state = MOTOR_STATE_TIMEOUT;
            }
            break;
            
        case MOTOR_STATE_WAIT_CALIBRATE:
            // 等待校准 - 简化为直接返回巡航
            if (current_time > fsm->calibration_timeout) {
                fsm->current_state = MOTOR_STATE_CRUISING;
            }
            break;
            
        case MOTOR_STATE_ADJUST:
            // 位置调整
            if (fsm->position_error == 0) {
                fsm->current_state = MOTOR_STATE_IDLE;
                break;
            }
            
            // 计算调整步数
            int adjust_steps = MotorFSM_CalculateAdjustSteps(fsm, fsm->position_error, DIR_UP);
            
            // 发送调整命令
            char cmd[64];
            snprintf(cmd, sizeof(cmd), "SetPos:%d,Speed:50", adjust_steps);
            MotorFSM_SendCANCommand(fsm, cmd);
            
            // 清除偏移
            fsm->position_error = 0;
            fsm->current_state = MOTOR_STATE_IDLE;
            break;
            
        case MOTOR_STATE_TIMEOUT:
            // 超时错误
            fsm->current_state = MOTOR_STATE_ERROR;
            break;
            
        case MOTOR_STATE_ERROR:
            // 错误状态
            if (fsm->retry_count < 3 && elapsed > 5000) {
                // 尝试恢复
                fsm->retry_count++;
                fsm->current_state = MOTOR_STATE_IDLE;
                fsm->start_time = current_time;
            }
            break;
    }
}

// 生成脉冲
void MotorFSM_GeneratePulse(MotorFSM_t* fsm, Direction_t dir, int speed) {
    // 构建CAN命令
    char cmd[64];
    int steps = speed * 10;  // 速度转换为步数
    
    if (dir == DIR_UP) {
        snprintf(cmd, sizeof(cmd), "SetPos:%d,Speed:%d", steps, speed);
    } else {
        snprintf(cmd, sizeof(cmd), "SetPos:-%d,Speed:%d", steps, speed);
    }
    
    MotorFSM_SendCANCommand(fsm, cmd);
    
    // 更新脉冲计数
    fsm->pulse_count += steps;
}

// 计算调整步数
int MotorFSM_CalculateAdjustSteps(MotorFSM_t* fsm, int offset, Direction_t dir) {
    // 基于偏移计算需要的步数
    int steps = abs(offset);
    
    // 限制最大调整步数
    if (steps > 500) {
        steps = 500;
    }
    
    // 根据方向决定正负
    if ((offset > 0 && dir == DIR_DOWN) || (offset < 0 && dir == DIR_UP)) {
        steps = -steps;
    }
    
    return steps;
}

// 发送CAN命令
void MotorFSM_SendCANCommand(MotorFSM_t* fsm, const char* cmd) {
    // 将字符串命令转换为CAN数据
    uint8_t can_data[8] = {0};
    
    // 简化的命令编码（实际应根据CAN协议）
    if (strstr(cmd, "SetPos:") != NULL) {
        int pos, speed;
        if (sscanf(cmd, "SetPos:%d,Speed:%d", &pos, &speed) == 2) {
            can_data[0] = 0x02;  // 命令类型
            can_data[1] = 0x01;
            can_data[2] = 0x20;
            can_data[3] = pos & 0xFF;
            can_data[4] = (pos >> 8) & 0xFF;
            can_data[5] = 0x00;
            can_data[6] = speed & 0xFF;
            can_data[7] = (speed >> 8) & 0xFF;
            
            CAN1_Send_Num(fsm->motor_adv->motor->motor_can_id, can_data);
        }
    }
}

// 启动移动
void MotorFSM_StartMoving(MotorFSM_t* fsm, Direction_t dir, int speed_percent) {
    if (fsm->current_state == MOTOR_STATE_IDLE) {
        // 设置目标
        fsm->target_position = 10000;  // 默认测试目标位置
        fsm->target_speed_percent = speed_percent;
        fsm->current_speed_percent = 0;
        fsm->start_position = fsm->motor_adv->actual_position;
        fsm->expected_pulses = abs(fsm->target_position - fsm->start_position);
        fsm->pulse_count = 0;
        
        // 启动状态机
        fsm->current_state = MOTOR_STATE_ACCELERATING;
        fsm->start_time = HAL_GetTick();
        
        // 生成第一个脉冲
        MotorFSM_GeneratePulse(fsm, dir, speed_percent);
    }
}

// 停止
void MotorFSM_Stop(MotorFSM_t* fsm) {
    MotorAdv_Stop(fsm->motor_adv);
    fsm->current_state = MOTOR_STATE_IDLE;
    fsm->current_speed_percent = 0;
}

// 调整位置
void MotorFSM_AdjustPosition(MotorFSM_t* fsm, int offset) {
    fsm->position_error = offset;
}

// 查询是否空闲
bool MotorFSM_IsIdle(MotorFSM_t* fsm) {
    return fsm->current_state == MOTOR_STATE_IDLE;
}

// 查询是否有错误
bool MotorFSM_HasError(MotorFSM_t* fsm) {
    return fsm->current_state == MOTOR_STATE_ERROR;
}

// 获取位置
int MotorFSM_GetPosition(MotorFSM_t* fsm) {
    return fsm->motor_adv->actual_position;
}