#include "display.h"

// U8g2全局对象
u8g2_t u8g2;

// 引脚定义
#define OLED_SCK_GPIO_Port  GPIOD
#define OLED_SCK_Pin        GPIO_PIN_14  // SCL
#define OLED_MOSI_GPIO_Port GPIOD
#define OLED_MOSI_Pin       GPIO_PIN_13  // SDA
#define OLED_DC_GPIO_Port   GPIOD
#define OLED_DC_Pin         GPIO_PIN_11  // DC
#define OLED_RES_GPIO_Port  GPIOD
#define OLED_RES_Pin        GPIO_PIN_12  // RES

// 软件SPI发送字节
static void OLED_SPI_SendByte(uint8_t byte) {
    for (int i = 0; i < 8; i++) {
        // 设置数据线
        if (byte & 0x80) {
            HAL_GPIO_WritePin(OLED_MOSI_GPIO_Port, OLED_MOSI_Pin, GPIO_PIN_SET);
        } else {
            HAL_GPIO_WritePin(OLED_MOSI_GPIO_Port, OLED_MOSI_Pin, GPIO_PIN_RESET);
        }

        // 时钟上升沿
        HAL_GPIO_WritePin(OLED_SCK_GPIO_Port, OLED_SCK_Pin, GPIO_PIN_SET);
        for(volatile int j = 0; j < 10; j++);  // 短延时

        // 时钟下降沿
        HAL_GPIO_WritePin(OLED_SCK_GPIO_Port, OLED_SCK_Pin, GPIO_PIN_RESET);

        byte <<= 1;
    }
}

// GPIO和延时回调函数
static uint8_t u8x8_gpio_and_delay_stm32(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr) {
    switch (msg) {
        case U8X8_MSG_GPIO_AND_DELAY_INIT:
            break;

        case U8X8_MSG_DELAY_MILLI:
            HAL_Delay(arg_int);
            break;

        case U8X8_MSG_DELAY_10MICRO:
            for(volatile int i = 0; i < 320; i++);
            break;

        case U8X8_MSG_DELAY_100NANO:
            __NOP();
            break;

        case U8X8_MSG_GPIO_DC:
            HAL_GPIO_WritePin(OLED_DC_GPIO_Port, OLED_DC_Pin, arg_int ? GPIO_PIN_SET : GPIO_PIN_RESET);
            break;

        case U8X8_MSG_GPIO_RESET:
            HAL_GPIO_WritePin(OLED_RES_GPIO_Port, OLED_RES_Pin, arg_int ? GPIO_PIN_SET : GPIO_PIN_RESET);
            break;

        case U8X8_MSG_GPIO_SPI_CLOCK:
            HAL_GPIO_WritePin(OLED_SCK_GPIO_Port, OLED_SCK_Pin, arg_int ? GPIO_PIN_SET : GPIO_PIN_RESET);
            break;

        case U8X8_MSG_GPIO_SPI_DATA:
            HAL_GPIO_WritePin(OLED_MOSI_GPIO_Port, OLED_MOSI_Pin, arg_int ? GPIO_PIN_SET : GPIO_PIN_RESET);
            break;

        default:
            return 0;
    }
    return 1;
}

// SPI字节发送回调
static uint8_t u8x8_byte_stm32_spi(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr) {
    uint8_t *data;

    switch (msg) {
        case U8X8_MSG_BYTE_SEND:
            data = (uint8_t *)arg_ptr;
            while (arg_int > 0) {
                OLED_SPI_SendByte(*data);
                data++;
                arg_int--;
            }
            break;

        case U8X8_MSG_BYTE_INIT:
            HAL_GPIO_WritePin(OLED_SCK_GPIO_Port, OLED_SCK_Pin, GPIO_PIN_RESET);
            HAL_GPIO_WritePin(OLED_MOSI_GPIO_Port, OLED_MOSI_Pin, GPIO_PIN_RESET);
            break;

        case U8X8_MSG_BYTE_SET_DC:
            HAL_GPIO_WritePin(OLED_DC_GPIO_Port, OLED_DC_Pin, arg_int ? GPIO_PIN_SET : GPIO_PIN_RESET);
            break;

        case U8X8_MSG_BYTE_START_TRANSFER:
        case U8X8_MSG_BYTE_END_TRANSFER:
            break;

        default:
            return 0;
    }
    return 1;
}

// 显示模块初始化
void Display_Init(void) {
    // 设置u8g2
    u8g2_Setup_ssd1306_128x64_noname_f(&u8g2, U8G2_R0, u8x8_byte_stm32_spi, u8x8_gpio_and_delay_stm32);

    // 初始化显示
    u8g2_InitDisplay(&u8g2);
    u8g2_SetPowerSave(&u8g2, 0);

    // 清屏
    u8g2_ClearBuffer(&u8g2);
    u8g2_SendBuffer(&u8g2);
}

// 显示步进电机状态
void Display_StepperStatus(StepperMotor_t* motor) {
    char buffer[32];

    u8g2_ClearBuffer(&u8g2);

    // 标题
    u8g2_SetFont(&u8g2, u8g2_font_6x10_tr);
    u8g2_DrawStr(&u8g2, 0, 10, "Stepper Motor Status");

    // 当前位置
    u8g2_SetFont(&u8g2, u8g2_font_ncenB08_tr);
    sprintf(buffer, "Position: %ld", StepperMotor_GetPosition(motor));
    u8g2_DrawStr(&u8g2, 0, 25, buffer);

    // 目标位置
    sprintf(buffer, "Target: %ld", StepperMotor_GetTargetPosition(motor));
    u8g2_DrawStr(&u8g2, 0, 37, buffer);

    // 运动状态
    u8g2_DrawStr(&u8g2, 0, 49, StepperMotor_IsMoving(motor) ? "Status: Moving" : "Status: Stopped");

    // 运动方向（仅在运动时显示）
    if (StepperMotor_IsMoving(motor)) {
        int32_t diff = StepperMotor_GetTargetPosition(motor) - StepperMotor_GetPosition(motor);
        u8g2_DrawStr(&u8g2, 0, 61, diff > 0 ? "Direction: CW" : "Direction: CCW");
    }

    u8g2_SendBuffer(&u8g2);
}

// 显示自定义文本
void Display_Text(uint8_t x, uint8_t y, const char* text) {
    u8g2_SetFont(&u8g2, u8g2_font_6x10_tr);
    u8g2_DrawStr(&u8g2, x, y, text);
}

// 清屏
void Display_Clear(void) {
    u8g2_ClearBuffer(&u8g2);
}

// 发送缓冲区到屏幕
void Display_Update(void) {
    u8g2_SendBuffer(&u8g2);
}

// 显示多行信息
void Display_MultiLine(const char* line1, const char* line2, const char* line3, const char* line4) {
    u8g2_ClearBuffer(&u8g2);
    u8g2_SetFont(&u8g2, u8g2_font_6x10_tr);

    if (line1) u8g2_DrawStr(&u8g2, 0, 10, line1);
    if (line2) u8g2_DrawStr(&u8g2, 0, 22, line2);
    if (line3) u8g2_DrawStr(&u8g2, 0, 34, line3);
    if (line4) u8g2_DrawStr(&u8g2, 0, 46, line4);

    u8g2_SendBuffer(&u8g2);
}

// 显示欢迎界面
void Display_Welcome(void) {
    u8g2_ClearBuffer(&u8g2);

    u8g2_SetFont(&u8g2, u8g2_font_ncenB14_tr);
    u8g2_DrawStr(&u8g2, 10, 20, "STM32");

    u8g2_SetFont(&u8g2, u8g2_font_ncenB08_tr);
    u8g2_DrawStr(&u8g2, 5, 35, "Stepper Motor");
    u8g2_DrawStr(&u8g2, 15, 50, "Controller");

    u8g2_SendBuffer(&u8g2);
}
