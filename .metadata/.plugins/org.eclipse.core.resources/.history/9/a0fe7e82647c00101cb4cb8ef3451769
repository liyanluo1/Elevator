/**
 * RS485通信测试程序 - Slave MCU
 * 用于调试RS485通信问题
 */

#include "rs485_test.h"
#include "rs485.h"
/* 先包含local_blackboard.h，避免宏定义冲突 */
#include "../Local_BB/local_blackboard.h"
#include "rs485_protocol.h"
#include "main.h"
#include <stdio.h>
#include <string.h>

/* 外部UART句柄 */
extern UART_HandleTypeDef huart2;

/* 测试状态 */
static struct {
    uint32_t test_count;
    uint32_t send_success;
    uint32_t send_fail;
    uint32_t recv_count;
    uint32_t last_test_time;
    uint8_t test_mode;  // 0=停止, 1=简单测试, 2=协议测试, 3=回环测试
    uint8_t echo_enabled;  // 回显使能
} test_state = {0};

/**
 * @brief 初始化RS485测试
 */
void RS485_Test_Init(void) {
    memset(&test_state, 0, sizeof(test_state));
    test_state.test_mode = 1;  // 默认简单测试模式
    test_state.echo_enabled = 1;  // 默认开启回显
    
    printf("\r\n=== RS485 TEST MODULE INITIALIZED (SLAVE) ===\r\n");
    printf("USART2 Configuration:\r\n");
    printf("  Baudrate: 115200\r\n");
    printf("  WordLength: 8 bits\r\n");
    printf("  StopBits: 1\r\n");
    printf("  Parity: None\r\n");
    printf("  Mode: TX_RX\r\n");
    printf("  Echo: %s\r\n", test_state.echo_enabled ? "ENABLED" : "DISABLED");
    printf("\r\n");
}

/**
 * @brief 发送简单测试数据包
 */
void RS485_Test_SendSimple(void) {
    uint8_t test_data[8] = {0x55, 0xAA, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60};
    
    // printf("[RS485_TEST] Sending simple test packet\r\n");
    printf("  Data: ");
    for(int i = 0; i < 8; i++) {
        printf("0x%02X ", test_data[i]);
    }
    printf("\r\n");
    
    /* 方法1: 使用HAL_UART_Transmit (阻塞式) */
    HAL_StatusTypeDef status = HAL_UART_Transmit(&huart2, test_data, 8, 100);
    
    if (status == HAL_OK) {
        test_state.send_success++;
        printf("  [OK] HAL_UART_Transmit success\r\n");
    } else {
        test_state.send_fail++;
        printf("  [FAIL] HAL_UART_Transmit error: %d\r\n", status);
    }
    
    /* 方法2: 尝试DMA发送 */
    rs485_status_t rs_status = rs485_send_packet_dma(test_data, 8);
    if (rs_status == RS485_OK) {
        printf("  [OK] DMA send initiated\r\n");
    } else if (rs_status == RS485_BUSY) {
        printf("  [BUSY] DMA is busy\r\n");
    } else {
        printf("  [FAIL] DMA send error\r\n");
    }
    
    test_state.test_count++;
}

/**
 * @brief 发送协议测试数据包（模拟按键）
 */
void RS485_Test_SendProtocol(void) {
    static uint8_t floor = 1;
    uint8_t cabin_call[4] = {CMD_CABIN_CALL, floor, 0, 0};
    
    printf("\r\n[TEST] Cabin Call Floor %d\r\n", floor);
    
    HAL_StatusTypeDef status = HAL_UART_Transmit(&huart2, cabin_call, 4, 100);
    
    if (status == HAL_OK) {
        test_state.send_success++;
        printf("  TX: 0x%02X 0x%02X 0x%02X 0x%02X\r\n", 
               cabin_call[0], cabin_call[1], cabin_call[2], cabin_call[3]);
        
        /* 循环楼层1-3 */
        floor++;
        if (floor > 3) floor = 1;
    } else {
        test_state.send_fail++;
        printf("  [FAIL] TX error: %d\r\n", status);
    }
}

/**
 * @brief 接收测试 - 检查接收缓冲区
 */
void RS485_Test_CheckReceive(void) {
    /* 方法1: 使用RS485驱动接收 */
    uint8_t rx_buffer[64];
    uint16_t rx_len = rs485_receive_packet(rx_buffer, sizeof(rx_buffer));
    
    if (rx_len > 0) {
        test_state.recv_count++;
        printf("[RS485_TEST] Received %d bytes via driver:\r\n", rx_len);
        printf("  Data: ");
        for(int i = 0; i < rx_len && i < 16; i++) {
            printf("0x%02X ", rx_buffer[i]);
        }
        printf("\r\n");
        
        /* 解析协议 */
        if (rx_len >= 2) {
            switch(rx_buffer[0]) {
                case CMD_DIRECTION_SET:
                    printf("  => DIRECTION_SET: Dir=%d, Cur=%d, Target=%d\r\n",
                           rx_buffer[1], rx_buffer[2], rx_buffer[3]);
                    break;
                case CMD_DOOR_OPEN:
                    printf("  => DOOR_OPEN command\r\n");
                    break;
                case CMD_DOOR_CLOSE:
                    printf("  => DOOR_CLOSE command\r\n");
                    break;
                case CMD_STATUS_REQUEST:
                    printf("  => STATUS_REQUEST\r\n");
                    /* 自动回复状态 */
                    RS485_Test_SendStatus();
                    break;
                default:
                    printf("  => Data/Unknown: 0x%02X\r\n", rx_buffer[0]);
            }
        }
        
        /* 如果开启回显，将数据发回 */
        if (test_state.echo_enabled && rx_buffer[0] == 0xEE) {
            printf("  [ECHO] Sending back loopback data\r\n");
            HAL_UART_Transmit(&huart2, rx_buffer, rx_len, 100);
        }
    }
    
    /* 方法2: 直接尝试HAL接收（非阻塞） */
    uint8_t direct_rx[4];
    HAL_StatusTypeDef status = HAL_UART_Receive(&huart2, direct_rx, 1, 1);
    if (status == HAL_OK) {
        printf("[RS485_TEST] Direct HAL receive: 0x%02X\r\n", direct_rx[0]);
        
        /* 尝试读取更多 */
        status = HAL_UART_Receive(&huart2, &direct_rx[1], 3, 10);
        if (status == HAL_OK) {
            printf("  More bytes: 0x%02X 0x%02X 0x%02X\r\n",
                   direct_rx[1], direct_rx[2], direct_rx[3]);
        }
    }
}

/**
 * @brief 发送状态响应
 */
void RS485_Test_SendStatus(void) {
    uint8_t status[4] = {CMD_STATUS_RESPONSE, 1, 0, 0};  // Floor 1, Stopped (0), Door Closed
    
    printf("[RS485_TEST] Sending status response\r\n");
    HAL_StatusTypeDef hal_status = HAL_UART_Transmit(&huart2, status, 4, 100);
    
    if (hal_status == HAL_OK) {
        printf("  [OK] Status sent\r\n");
    } else {
        printf("  [FAIL] Send error\r\n");
    }
}

/**
 * @brief 模拟光电传感器触发
 */
void RS485_Test_SimulatePhotoSensor(void) {
    static uint8_t floor = 1;
    uint8_t photo_data[4] = {CMD_PHOTO_SENSOR, floor, 0, 0};
    
    printf("[RS485_TEST] Simulating photo sensor at floor %d\r\n", floor);
    
    HAL_StatusTypeDef status = HAL_UART_Transmit(&huart2, photo_data, 4, 100);
    
    if (status == HAL_OK) {
        printf("  [OK] Photo sensor event sent\r\n");
        floor++;
        if (floor > 3) floor = 1;
    } else {
        printf("  [FAIL] Send error\r\n");
    }
}

/**
 * @brief RS485测试主处理函数
 */
void RS485_Test_Process(void) {
    uint32_t current_time = HAL_GetTick();
    
    /* 先检查接收（总是检查） */
    RS485_Test_CheckReceive();
    
    /* 每3秒执行一次发送测试 */
    if (current_time - test_state.last_test_time < 3000) {
        return;
    }
    test_state.last_test_time = current_time;
    
    /* 根据测试模式执行不同测试 */
    switch(test_state.test_mode) {
        case 1:  // 简单测试
            RS485_Test_SendSimple();
            break;
            
        case 2:  // 协议测试（内呼）
            RS485_Test_SendProtocol();
            break;
            
        case 3:  // 光电传感器模拟
            RS485_Test_SimulatePhotoSensor();
            break;
            
        default:
            break;
    }
    
    /* 每20次打印统计 */
    if (test_state.test_count % 20 == 0 && test_state.test_count > 0) {
        RS485_Test_PrintStats();
    }
}

/**
 * @brief 设置测试模式
 */
void RS485_Test_SetMode(uint8_t mode) {
    test_state.test_mode = mode;
    printf("[RS485_TEST] Mode set to %d\r\n", mode);
}

/**
 * @brief 设置回显模式
 */
void RS485_Test_SetEcho(uint8_t enable) {
    test_state.echo_enabled = enable;
    printf("[RS485_TEST] Echo %s\r\n", enable ? "ENABLED" : "DISABLED");
}

/**
 * @brief 打印测试统计
 */
void RS485_Test_PrintStats(void) {
    printf("\r\n=== RS485 TEST STATISTICS (SLAVE) ===\r\n");
    printf("Test Count: %lu\r\n", test_state.test_count);
    printf("Send Success: %lu\r\n", test_state.send_success);
    printf("Send Fail: %lu\r\n", test_state.send_fail);
    printf("Receive Count: %lu\r\n", test_state.recv_count);
    printf("Echo Mode: %s\r\n", test_state.echo_enabled ? "ON" : "OFF");
    
    /* 获取RS485驱动统计 */
    rs485_stats_t stats;
    rs485_get_stats(&stats);
    printf("\r\nDriver Stats:\r\n");
    printf("  TX Packets: %lu\r\n", stats.tx_packets);
    printf("  TX Bytes: %lu\r\n", stats.tx_bytes);
    printf("  TX Errors: %lu\r\n", stats.tx_errors);
    printf("  RX Packets: %lu\r\n", stats.rx_packets);
    printf("  RX Bytes: %lu\r\n", stats.rx_bytes);
    printf("  RX Errors: %lu\r\n", stats.rx_errors);
    printf("====================================\r\n\r\n");
}

/**
 * @brief 手动发送测试命令
 */
void RS485_Test_SendCommand(uint8_t cmd, uint8_t param1, uint8_t param2, uint8_t param3) {
    uint8_t data[4] = {cmd, param1, param2, param3};
    
    printf("[RS485_TEST] Manual command: ");
    printf("CMD=0x%02X P1=%d P2=%d P3=%d\r\n", cmd, param1, param2, param3);
    
    HAL_StatusTypeDef status = HAL_UART_Transmit(&huart2, data, 4, 100);
    
    if (status == HAL_OK) {
        printf("  [OK] Sent successfully\r\n");
    } else {
        printf("  [FAIL] Send error: %d\r\n", status);
    }
}