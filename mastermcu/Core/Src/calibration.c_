#include "calibration.h"
#include <stdio.h>
#include <string.h>

// 初始化校准模块//@简化calibration process 
void Calibration_Init(Calibration_t* calib, MotorAdvanced_t* motor_adv) {
    memset(calib, 0, sizeof(Calibration_t));
    
    calib->motor_adv = motor_adv;
    calib->state = CALIB_STATE_IDLE;
    
    // 设置默认参数
    calib->homing_speed = 300;      // 慢速归位
    calib->approach_speed = 100;    // 极慢接近速度
    calib->backoff_distance = 500;  // 反向500脉冲
    calib->timeout = 30000;         // 30秒超时
}

// 开始校准
void Calibration_Start(Calibration_t* calib) {
    printf("Calibration: Starting homing sequence\n");
    
    calib->state = CALIB_STATE_HOMING;
    calib->start_time = HAL_GetTick();
    calib->state_time = calib->start_time;
    calib->retry_count = 0;
    calib->is_calibrated = false;
    calib->sensor_triggered = false;
    
    // 设置电机为未校准状态
    calib->motor_adv->is_calibrated = false;
    g_blackboard.motor.is_calibrated = false;
    
    // 开始归位
    MotorAdv_StartHoming(calib->motor_adv);
}

// 主处理函数
void Calibration_Process(Calibration_t* calib) {
    if (calib->state == CALIB_STATE_IDLE || calib->state == CALIB_STATE_COMPLETE) {
        return;
    }
    
    uint32_t current_time = HAL_GetTick();
    uint32_t elapsed = current_time - calib->state_time;
    
    // 检查总超时
    if (current_time - calib->start_time > calib->timeout) {
        printf("Calibration: Timeout error\n");
        calib->state = CALIB_STATE_ERROR;
        return;
    }
    
    switch (calib->state) {
        case CALIB_STATE_HOMING:
            // 等待传感器触发
            if (calib->sensor_triggered) {
                printf("Calibration: Sensor triggered, stopping motor\n");
                MotorAdv_EmergencyStop(calib->motor_adv);
                calib->state = CALIB_STATE_BACKOFF;
                calib->state_time = current_time;
                calib->sensor_triggered = false;
            }
            break;
            
        case CALIB_STATE_BACKOFF:
            // 等待电机停止
            if (!calib->motor_adv->motor->is_moving && elapsed > 500) {
                printf("Calibration: Backing off from sensor\n");
                // 反向移动离开传感器
                MotorAdv_MoveRelative(calib->motor_adv, calib->backoff_distance);
                calib->state = CALIB_STATE_WAIT_SENSOR;
                calib->state_time = current_time;
            }
            break;
            
        case CALIB_STATE_WAIT_SENSOR:
            // 等待离开传感器
            if (!g_blackboard.sensors.sensor_triggered[0] && 
                !calib->motor_adv->motor->is_moving && 
                elapsed > 1000) {
                printf("Calibration: Approaching sensor slowly\n");
                // 慢速接近传感器
                calib->motor_adv->profile.cruise_speed = calib->approach_speed;
                MotorAdv_MoveRelative(calib->motor_adv, -calib->backoff_distance * 2);
                calib->state = CALIB_STATE_APPROACH;
                calib->state_time = current_time;
            }
            break;
            
        case CALIB_STATE_APPROACH:
            // 等待再次触发传感器
            if (calib->sensor_triggered) {
                printf("Calibration: Sensor triggered at approach, setting zero\n");
                MotorAdv_EmergencyStop(calib->motor_adv);
                calib->state = CALIB_STATE_SET_ZERO;
                calib->state_time = current_time;
            }
            break;
            
        case CALIB_STATE_SET_ZERO:
            // 设置零点
            if (!calib->motor_adv->motor->is_moving && elapsed > 500) {
                printf("Calibration: Setting home position\n");
                MotorAdv_SetHomePosition(calib->motor_adv);
                calib->floor_positions[0] = 0;  // 底层位置为0
                
                // 计算其他楼层位置
                for (int i = 1; i < MAX_FLOORS; i++) {
                    calib->floor_positions[i] = i * g_blackboard.floor_height_pulses;
                }
                
                // 更新黑板数据
                g_blackboard.current_floor = 0;
                g_blackboard.motor.current_position = 0;
                g_blackboard.motor.is_calibrated = true;
                
                // 移动到1楼（如果不在1楼）
                if (g_blackboard.current_floor != 1) {
                    calib->target_floor = 1;
                    calib->state = CALIB_STATE_MOVE_TO_FLOOR;
                } else {
                    calib->state = CALIB_STATE_VERIFY;
                }
                calib->state_time = current_time;
            }
            break;
            
        case CALIB_STATE_MOVE_TO_FLOOR:
            // 移动到目标楼层
            if (!calib->motor_adv->motor->is_moving && elapsed > 500) {
                printf("Calibration: Moving to floor %d\n", calib->target_floor);
                int32_t target_pos = calib->floor_positions[calib->target_floor];
                MotorAdv_MoveToPosition(calib->motor_adv, target_pos);
                calib->state = CALIB_STATE_VERIFY;
                calib->state_time = current_time;
            }
            break;
            
        case CALIB_STATE_VERIFY:
            // 验证位置
            if (MotorAdv_IsAtTarget(calib->motor_adv) && elapsed > 1000) {
                printf("Calibration: Complete! Current floor: %d\n", g_blackboard.current_floor);
                calib->is_calibrated = true;
                calib->state = CALIB_STATE_COMPLETE;
                
                // 发送校准完成事件
                Blackboard_PushEvent(EVENT_CALIBRATION_DONE, g_blackboard.current_floor);
            }
            break;
            
        case CALIB_STATE_ERROR:
            // 错误处理
            MotorAdv_EmergencyStop(calib->motor_adv);
            if (elapsed > 5000) {
                // 5秒后重试
                if (calib->retry_count < 3) {
                    calib->retry_count++;
                    printf("Calibration: Retrying... (attempt %d)\n", calib->retry_count);
                    Calibration_Start(calib);
                } else {
                    printf("Calibration: Failed after %d attempts\n", calib->retry_count);
                    calib->state = CALIB_STATE_IDLE;
                }
            }
            break;
            
        default:
            break;
    }
}

// 传感器触发事件处理
void Calibration_OnSensorTriggered(Calibration_t* calib, uint8_t floor) {
    if (calib->state == CALIB_STATE_HOMING || 
        calib->state == CALIB_STATE_APPROACH) {
        calib->sensor_triggered = true;
        printf("Calibration: Sensor triggered at floor %d\n", floor);
        
        // 如果在运行中触发传感器，更新楼层位置
        if (calib->is_calibrated && calib->state == CALIB_STATE_IDLE) {
            Calibration_UpdateFloorPosition(calib, floor);
        }
    }
}

// 查询是否完成
bool Calibration_IsComplete(Calibration_t* calib) {
    return calib->state == CALIB_STATE_COMPLETE && calib->is_calibrated;
}

// 查询是否正在运行
bool Calibration_IsRunning(Calibration_t* calib) {
    return calib->state != CALIB_STATE_IDLE && 
           calib->state != CALIB_STATE_COMPLETE && 
           calib->state != CALIB_STATE_ERROR;
}

// 查询是否有错误
bool Calibration_HasError(Calibration_t* calib) {
    return calib->state == CALIB_STATE_ERROR;
}

// 获取当前状态
CalibState_t Calibration_GetState(Calibration_t* calib) {
    return calib->state;
}

// 设置楼层位置
void Calibration_SetFloorPosition(Calibration_t* calib, uint8_t floor, int32_t position) {
    if (floor < MAX_FLOORS) {
        calib->floor_positions[floor] = position;
        g_blackboard.floors[floor].position_pulse = position;
    }
}

// 获取楼层位置
int32_t Calibration_GetFloorPosition(Calibration_t* calib, uint8_t floor) {
    if (floor < MAX_FLOORS) {
        return calib->floor_positions[floor];
    }
    return 0;
}

// 运行时更新楼层位置（校准误差）
void Calibration_UpdateFloorPosition(Calibration_t* calib, uint8_t floor) {
    if (floor >= MAX_FLOORS || !calib->is_calibrated) {
        return;
    }
    
    // 获取当前实际位置
    int32_t current_pos = calib->motor_adv->actual_position;
    int32_t expected_pos = calib->floor_positions[floor];
    int32_t error = current_pos - expected_pos;
    
    printf("Calibration: Floor %d position error: %ld pulses\n", floor, error);
    
    // 如果误差较大，更新位置
    if (abs(error) > 50) {  // 50脉冲容差
        // 更新当前楼层位置
        calib->floor_positions[floor] = current_pos;
        
        // 校正电机位置
        MotorAdv_CorrectPosition(calib->motor_adv, expected_pos);
        
        printf("Calibration: Corrected position for floor %d\n", floor);
    }
}